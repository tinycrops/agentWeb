/**
 * BaseAgent
 * 
 * Abstract base class for all agents in the system.
 * Handles common functionality like subscribing to events and publishing derived events.
 */
const EventBroker = require('../core/EventBroker');

class BaseAgent {
  /**
   * Create a new agent
   * 
   * @param {Object} options - Agent configuration
   * @param {string} options.id - Unique identifier for this agent
   * @param {string} options.name - Human-readable name
   * @param {EventBroker} options.broker - Event broker to use
   * @param {Array<string>} options.subscribedEvents - Event kinds to subscribe to
   */
  constructor(options = {}) {
    this.id = options.id || `agent-${Date.now()}`;
    this.name = options.name || this.constructor.name;
    this.broker = options.broker || null;
    this.subscribedEvents = options.subscribedEvents || [];
    this.subscriptions = [];
    this.isInitialized = false;
    this.isRunning = false;
  }

  /**
   * Initialize the agent and subscribe to events
   * 
   * @param {EventBroker} broker - Event broker to use if not provided in constructor
   */
  async initialize(broker = null) {
    if (this.isInitialized) return;

    if (broker) {
      this.broker = broker;
    }

    if (!this.broker) {
      throw new Error('Event broker is required');
    }

    // Ensure broker is initialized
    await this.broker.initialize();

    this.isInitialized = true;
    console.log(`Agent ${this.name} (${this.id}) initialized`);
  }

  /**
   * Start the agent (subscribe to events)
   */
  async start() {
    if (!this.isInitialized) {
      await this.initialize();
    }

    if (this.isRunning) return;

    // Subscribe to all specified events
    for (const eventKind of this.subscribedEvents) {
      const subscription = await this.broker.subscribe(
        eventKind,
        this.processEvent.bind(this),
        {
          groupName: this.name,
          consumerName: `${this.id}-${eventKind}`
        }
      );
      this.subscriptions.push(subscription);
    }

    this.isRunning = true;
    console.log(`Agent ${this.name} (${this.id}) started`);
  }

  /**
   * Stop the agent (unsubscribe from all events)
   */
  async stop() {
    if (!this.isRunning) return;

    // Unsubscribe from all events
    for (const subscription of this.subscriptions) {
      await this.broker.unsubscribe(subscription);
    }
    this.subscriptions = [];

    this.isRunning = false;
    console.log(`Agent ${this.name} (${this.id}) stopped`);
  }

  /**
   * Process an incoming event from subscriptions
   * This is the main method that specialized agents will override
   * 
   * @param {Event} event - Incoming event to process
   */
  async processEvent(event) {
    throw new Error('processEvent must be implemented by subclasses');
  }

  /**
   * Publish a derived event
   * 
   * @param {Event} event - Event to publish
   * @returns {boolean} Whether the event was published successfully
   */
  async publishEvent(event) {
    if (!this.isInitialized || !this.broker) {
      throw new Error('Agent not initialized');
    }

    try {
      // Verify the event was generated by this agent
      if (event.source !== this.id) {
        console.warn(`Event source ${event.source} doesn't match agent ID ${this.id}`);
      }

      const result = await this.broker.publish(event);
      return result;
    } catch (error) {
      console.error(`Failed to publish event from agent ${this.name}:`, error);
      return false;
    }
  }

  /**
   * Check if an event should be processed by this agent
   * This is a hook that specialized agents can use to filter events
   * 
   * @param {Event} event - Event to check
   * @returns {boolean} Whether the event should be processed
   */
  shouldProcessEvent(event) {
    return this.subscribedEvents.includes(event.kind);
  }
}

module.exports = BaseAgent; 