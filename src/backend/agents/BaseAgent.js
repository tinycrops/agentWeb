/**
 * BaseAgent
 * 
 * Abstract base class for all agents in the system.
 * Handles common functionality like subscribing to events and publishing derived events.
 */
const EventBroker = require('../core/EventBroker');
const fs = require('fs').promises;
const path = require('path');

class BaseAgent {
  /**
   * Create a new agent
   * 
   * @param {Object} options - Agent configuration
   * @param {string} options.id - Unique identifier for this agent
   * @param {string} options.name - Human-readable name
   * @param {EventBroker} options.broker - Event broker to use
   * @param {Array<string>} options.subscribedEvents - Event kinds to subscribe to
   * @param {number} options.snapshotInterval - Number of events to process before taking a snapshot
   * @param {string} options.snapshotDir - Directory to store snapshots
   */
  constructor(options = {}) {
    this.id = options.id || `agent-${Date.now()}`;
    this.name = options.name || this.constructor.name;
    this.broker = options.broker || null;
    this.subscribedEvents = options.subscribedEvents || [];
    this.subscriptions = [];
    this.isInitialized = false;
    this.isRunning = false;
    this.processedEventCount = 0;
    this.snapshotInterval = options.snapshotInterval || 0; // 0 = disabled
    this.snapshotDir = options.snapshotDir || './snapshots';
    this.lastSnapshotId = null;
  }

  /**
   * Initialize the agent and subscribe to events
   * 
   * @param {EventBroker} broker - Event broker to use if not provided in constructor
   */
  async initialize(broker = null) {
    if (this.isInitialized) return;

    if (broker) {
      this.broker = broker;
    }

    if (!this.broker) {
      throw new Error('Event broker is required');
    }

    // Ensure broker is initialized
    await this.broker.initialize();

    // Create snapshot directory if it doesn't exist and snapshots are enabled
    if (this.snapshotInterval > 0) {
      try {
        await fs.mkdir(this.snapshotDir, { recursive: true });
      } catch (error) {
        console.warn(`Failed to create snapshot directory: ${error.message}`);
      }
      
      // Try to load the latest snapshot
      await this.loadLatestSnapshot();
    }

    this.isInitialized = true;
    console.log(`Agent ${this.name} (${this.id}) initialized`);
  }

  /**
   * Start the agent (subscribe to events)
   */
  async start() {
    if (!this.isInitialized) {
      await this.initialize();
    }

    if (this.isRunning) return;

    // Subscribe to all specified events
    for (const eventKind of this.subscribedEvents) {
      const subscription = await this.broker.subscribe(
        eventKind,
        this.processEvent.bind(this),
        {
          groupName: this.name,
          consumerName: `${this.id}-${eventKind}`
        }
      );
      this.subscriptions.push(subscription);
    }

    this.isRunning = true;
    console.log(`Agent ${this.name} (${this.id}) started`);
  }

  /**
   * Stop the agent (unsubscribe from all events)
   */
  async stop() {
    if (!this.isRunning) return;

    // Take a final snapshot before stopping
    if (this.snapshotInterval > 0) {
      await this.takeSnapshot();
    }

    // Unsubscribe from all events
    for (const subscription of this.subscriptions) {
      await this.broker.unsubscribe(subscription);
    }
    this.subscriptions = [];

    this.isRunning = false;
    console.log(`Agent ${this.name} (${this.id}) stopped`);
  }

  /**
   * Process an incoming event from subscriptions
   * This is the main method that specialized agents will override
   * 
   * @param {Event} event - Incoming event to process
   */
  async processEvent(event) {
    if (!this.shouldProcessEvent(event)) return;
    
    // Increment event counter and check if snapshot should be taken
    this.processedEventCount++;
    
    // Take snapshot if interval is reached
    if (this.snapshotInterval > 0 && this.processedEventCount % this.snapshotInterval === 0) {
      await this.takeSnapshot(event.id);
    }
    
    // This is now a base implementation, not an error
    // It does the common tasks and can be extended by subclasses
    return event;
  }

  /**
   * Publish a derived event
   * 
   * @param {Event} event - Event to publish
   * @returns {boolean} Whether the event was published successfully
   */
  async publishEvent(event) {
    if (!this.isInitialized || !this.broker) {
      throw new Error('Agent not initialized');
    }

    try {
      // Verify the event was generated by this agent
      if (event.source !== this.id) {
        console.warn(`Event source ${event.source} doesn't match agent ID ${this.id}`);
      }

      const result = await this.broker.publish(event);
      return result;
    } catch (error) {
      console.error(`Failed to publish event from agent ${this.name}:`, error);
      return false;
    }
  }

  /**
   * Check if an event should be processed by this agent
   * This is a hook that specialized agents can use to filter events
   * 
   * @param {Event} event - Event to check
   * @returns {boolean} Whether the event should be processed
   */
  shouldProcessEvent(event) {
    return this.subscribedEvents.includes(event.kind);
  }

  /**
   * Get a snapshot of the agent's state
   * Implement in subclasses to provide state-specific snapshot data
   * 
   * @returns {Object|null} The agent's state or null if not implemented
   */
  getSnapshot() {
    // Base implementation returns minimal state
    return {
      id: this.id,
      name: this.name,
      processedEventCount: this.processedEventCount,
      lastEventTimestamp: Date.now()
    };
  }

  /**
   * Load a snapshot into the agent's state
   * Implement in subclasses to restore from snapshot data
   * 
   * @param {Object} snapshot - The snapshot to load
   * @returns {boolean} Whether the snapshot was loaded successfully
   */
  loadSnapshot(snapshot) {
    if (!snapshot) return false;
    
    // Base implementation only restores basic counters
    this.processedEventCount = snapshot.processedEventCount || 0;
    return true;
  }

  /**
   * Take a snapshot of the agent's state and save it
   * 
   * @param {string} eventId - ID of the event that triggered the snapshot
   * @returns {boolean} Whether the snapshot was saved successfully
   */
  async takeSnapshot(eventId = null) {
    if (this.snapshotInterval <= 0) return false;
    
    try {
      const snapshot = this.getSnapshot();
      if (!snapshot) return false;
      
      // Add metadata
      snapshot.timestamp = Date.now();
      snapshot.eventId = eventId;
      snapshot.agentId = this.id;
      snapshot.agentName = this.name;
      
      const filename = path.join(
        this.snapshotDir, 
        `${this.name}-${this.id}-${snapshot.timestamp}.json`
      );
      
      await fs.writeFile(filename, JSON.stringify(snapshot, null, 2));
      this.lastSnapshotId = filename;
      
      console.log(`Agent ${this.name} snapshot saved to ${filename}`);
      return true;
    } catch (error) {
      console.error(`Failed to save snapshot for agent ${this.name}:`, error);
      return false;
    }
  }

  /**
   * Load the latest snapshot for this agent
   * 
   * @returns {boolean} Whether a snapshot was loaded successfully
   */
  async loadLatestSnapshot() {
    try {
      // Find all snapshot files for this agent
      const files = await fs.readdir(this.snapshotDir);
      const snapshotFiles = files.filter(file => 
        file.startsWith(`${this.name}-${this.id}`) && file.endsWith('.json')
      );
      
      if (snapshotFiles.length === 0) return false;
      
      // Sort by timestamp (most recent first)
      snapshotFiles.sort().reverse();
      
      // Load the most recent snapshot
      const snapshotPath = path.join(this.snapshotDir, snapshotFiles[0]);
      const data = await fs.readFile(snapshotPath, 'utf8');
      const snapshot = JSON.parse(data);
      
      const success = this.loadSnapshot(snapshot);
      if (success) {
        this.lastSnapshotId = snapshotPath;
        console.log(`Agent ${this.name} restored from snapshot ${snapshotPath}`);
      }
      
      return success;
    } catch (error) {
      console.warn(`Failed to load snapshot for agent ${this.name}:`, error);
      return false;
    }
  }
}

module.exports = BaseAgent; 